import { roundToPlace } from '@toolkip/maths';
import { Color, _Color } from '../colors';
import { LUM_ADDEND } from '../_constants';
import { IColorMultipliers } from '../_interfaces';

const getColor = (col: string | _Color): _Color => {
    if (typeof col === "string") {
        return new Color(col);
    } else {
        return col;
    }
}
/**
 * getApparentColor
 * ----------------------------------------------------------------------------
 * Calculates what the display color of this color would be without setting an alpha value.
 * Can calculate what the RGB value should be given a background color instead of relying
 * on RGBA being supported.
 * 
 * @param   colA    The foreground color
 * @param 	colB 	The background color
 * 
 * @returns The color that is generated by applying colA over colB 
 */
export const getApparentColor = (colA: _Color | string, colB: _Color | string): _Color => {
    const colorA = getColor(colA);
    const colorB = getColor(colB);
    const out = getColor("#000000");

    const antiAlpha = 1 - colorA.alpha;

    out.red = Math.round((colorA.red * colorA.alpha) + (colorB.red * antiAlpha));
    out.green = Math.round((colorA.green * colorA.alpha) + (colorB.green * antiAlpha));
    out.blue = Math.round((colorB.blue * colorA.alpha) + (colorB.blue * antiAlpha));
    out.alpha = 1;

    return out;
};

/**
 * compareColors
 * ----------------------------------------------------------------------------
 * Finds how similar two colors are based on their HSL values
 * @param   colA        The root color
 * @param   colB        The color we are comparing to
 * @param   multipliers The multipliers we should use to calculate the diff
 * @returns An object containing the total diff calculation as well as the raw 
 *          diff values
 */
export const compareColors = (colA: string | _Color, colB: string | _Color, multipliers: IColorMultipliers): IColorMultipliers => {

    const colorA = getColor(colA)
    const colorB = getColor(colB);

    // If we didn't get multiplers, set some defaults
    if (!multipliers) {
        multipliers = {
            hue: 1,
            saturation: 0.04,
            lightness: 0.04,
            alpha: 0.04
        }
    }

    // Make sure we have HSL for both colors
    colorA.generateHslValues();
    colorB.generateHslValues();

    // Grab the differences between the values
    const diffs = {
        total: 0,
        hue: (colorB.hue - colorA.hue),
        saturation: (colorB.saturation - colorA.saturation),
        lightness: (colorB.lightness - colorA.lightness),
        alpha: (colorB.alpha - colorA.alpha)
    };

    // Calculate the total diff
    diffs.total += (Math.abs(diffs.hue) * (multipliers.hue || 0));
    diffs.total += (Math.abs(diffs.saturation) * (multipliers.saturation || 0));
    diffs.total += (Math.abs(diffs.lightness) * (multipliers.lightness || 0));
    diffs.total += (Math.abs(diffs.alpha) * (multipliers.alpha || 0));

    // return our diffs array
    return diffs;
}

/**
 * averageIn
 * ----------------------------------------------------------------------------
 * Averages in another color into this one
 * @param   colA    The root color
 * @param   colB    The color to average in
 * @returns The resulting merged color
 */
export const averageIn = (colA: string | _Color, colB: string | _Color): _Color => {
    const colorA = getColor(colA);
    const colorB = getColor(colB);

    let avgs: { hue: number, saturation: number, lightness: number, alpha: number };

    // Make sure we have HSL values for both colors
    colorA.generateHslValues();
    colorB.generateHslValues();

    // Calculate the averages
    avgs = {
        hue: ((colorA.hue + colorB.hue) / 2),
        saturation: ((colorA.saturation + colorB.saturation) / 2),
        lightness: ((colorA.lightness + colorB.lightness) / 2),
        alpha: ((colorA.alpha + colorB.alpha) / 2)
    };

    const out = new Color("#000000");

    // Set these averaged values as our colors new colors
    out.hue = Math.round(avgs.hue);
    out.saturation = (Math.floor(avgs.saturation * 10) / 10);
    out.lightness = (Math.floor(avgs.lightness * 10) / 10);
    out.alpha = (Math.floor(avgs.alpha * 10) / 10);

    return out;
}

/**
 * calculateContrast
 * ----------------------------------------------------------------------------
 * determine the contrast value between two colors
 * @param   colA    The background color
 * @param   colB    The foreground color
 * @returns The ratio between the two colors; used to determine A11Y color 
 *          contrast.
 */
export const calculateContrast = (colA: string | _Color, colB: string | _Color) => {
    const colorA = getColor(colA);
    const colorB = getColor(colB)

    const lumA = colorA.luminance / 100;
    const lumB = colorB.luminance / 100;

    const brightest = Math.max(lumA, lumB);
    const dimmest = Math.min(lumA, lumB);

    return roundToPlace((brightest + LUM_ADDEND) / (dimmest + LUM_ADDEND), 100);
}